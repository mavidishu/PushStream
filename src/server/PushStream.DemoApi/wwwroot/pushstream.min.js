/*!
 * PushStream JavaScript Client v0.1.0
 * A lightweight, zero-dependency SSE client library
 * (c) 2026
 * Released under the MIT License
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).PushStream={})}(this,function(e){"use strict";const t=Object.freeze({DISCONNECTED:"disconnected",CONNECTING:"connecting",CONNECTED:"connected"}),s=Object.freeze({OPEN:"stream.open",CLOSE:"stream.close",ERROR:"stream.error",STATE_CHANGE:"stream.statechange"}),n=Object.freeze({reconnect:!0,reconnectInterval:1e3,maxReconnectAttempts:10,maxReconnectDelay:3e4,withCredentials:!1});class i{constructor(){this._listeners=new Map}add(e,t){if("function"!=typeof t)throw new TypeError("Callback must be a function");this._listeners.has(e)||this._listeners.set(e,new Set);const s=this._listeners.get(e),n=s.has(t);return s.add(t),!n}remove(e,t){const s=this._listeners.get(e);if(!s)return!1;const n=s.delete(t);return 0===s.size&&this._listeners.delete(e),n}removeAll(e){return this._listeners.delete(e)}emit(e,t){const s=this._listeners.get(e);if(!s||0===s.size)return;const n=Array.from(s);for(const s of n)try{s(t)}catch(t){console.error(`Error in event callback for "${e}":`,t)}}has(e){const t=this._listeners.get(e);return void 0!==t&&t.size>0}getEvents(){return Array.from(this._listeners.keys())}getCount(e){const t=this._listeners.get(e);return t?t.size:0}clear(){this._listeners.clear()}}e.BuiltInEvents=s,e.ConnectionState=t,e.DefaultOptions=n,e.EventClient=class{constructor(e,s={}){if(!e||"string"!=typeof e)throw new TypeError("URL must be a non-empty string");this._url=e,this._options={...n,...s},this._eventSource=null,this._subscriptions=new i,this._state=t.DISCONNECTED,this._reconnectAttempts=0,this._reconnectTimer=null,this._manualDisconnect=!1,this._registeredEventTypes=new Set}get state(){return this._state}get url(){return this._url}connect(){if(this._state===t.DISCONNECTED){this._manualDisconnect=!1,this._setState(t.CONNECTING);try{this._eventSource=new EventSource(this._url,{withCredentials:this._options.withCredentials}),this._eventSource.onopen=()=>this._handleOpen(),this._eventSource.onerror=e=>this._handleError(e),this._registerEventListeners()}catch(e){this._handleConnectionError(e)}}}disconnect(){this._manualDisconnect=!0,this._cleanup(),this._state!==t.DISCONNECTED&&(this._setState(t.DISCONNECTED),this._emit(s.CLOSE,{manual:!0}))}on(e,t){if("string"!=typeof e||!e)throw new TypeError("Event name must be a non-empty string");if("function"!=typeof t)throw new TypeError("Callback must be a function");return this._subscriptions.add(e,t),!this._eventSource||this._isBuiltInEvent(e)||this._registeredEventTypes.has(e)||this._registerSingleEventListener(e),this}off(e,t){if("string"!=typeof e||!e)throw new TypeError("Event name must be a non-empty string");return void 0!==t?this._subscriptions.remove(e,t):this._subscriptions.removeAll(e),this}_setState(e){const t=this._state;t!==e&&(this._state=e,this._emit(s.STATE_CHANGE,{previousState:t,currentState:e}))}_emit(e,t){this._subscriptions.emit(e,t)}_handleOpen(){this._reconnectAttempts=0,this._setState(t.CONNECTED),this._emit(s.OPEN,{url:this._url})}_handleError(e){const t={message:"Connection error",readyState:this._eventSource?.readyState};this._emit(s.ERROR,t),this._eventSource?.readyState===EventSource.CLOSED&&this._handleConnectionLoss()}_handleConnectionError(e){this._setState(t.DISCONNECTED),this._emit(s.ERROR,{message:e.message||"Failed to create connection",error:e})}_handleConnectionLoss(){this._cleanup(),this._setState(t.DISCONNECTED),this._emit(s.CLOSE,{manual:!1}),this._options.reconnect&&!this._manualDisconnect&&this._scheduleReconnect()}_scheduleReconnect(){if(this._manualDisconnect)return;if(this._reconnectAttempts>=this._options.maxReconnectAttempts)return void this._emit(s.ERROR,{message:"Max reconnection attempts reached",attempts:this._reconnectAttempts});const e=this._options.reconnectInterval*Math.pow(2,this._reconnectAttempts),t=Math.min(e,this._options.maxReconnectDelay)+1e3*Math.random();this._reconnectTimer=setTimeout(()=>{this._reconnectAttempts++,this.connect()},t)}_registerEventListeners(){const e=this._subscriptions.getEvents();for(const t of e)this._isBuiltInEvent(t)||this._registerSingleEventListener(t)}_registerSingleEventListener(e){this._eventSource&&!this._registeredEventTypes.has(e)&&(this._registeredEventTypes.add(e),this._eventSource.addEventListener(e,t=>{this._handleMessage(e,t)}))}_handleMessage(e,t){let n;try{n=JSON.parse(t.data)}catch(n){return void this._emit(s.ERROR,{message:"Failed to parse JSON payload",eventType:e,originalData:t.data,error:n.message})}this._emit(e,n)}_isBuiltInEvent(e){return e.startsWith("stream.")}_cleanup(){this._reconnectTimer&&(clearTimeout(this._reconnectTimer),this._reconnectTimer=null),this._eventSource&&(this._eventSource.close(),this._eventSource=null),this._registeredEventTypes.clear()}},e.SubscriptionManager=i});
//# sourceMappingURL=pushstream.min.js.map
